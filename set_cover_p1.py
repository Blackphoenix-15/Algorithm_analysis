# -*- coding: utf-8 -*-
"""set_cover_p1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I-KzY1wwCi6BP_Khf3jBxJsELxYj29ak
"""

__author__ = "Andrea Rubbi"
import time


def set_cover(universe, subsets,costs):
    cost=0
    elements = set(e for s in subsets for e in s)
    if elements != universe:
        return None
    covered = set()
    cover = []
    while covered != elements:
        subset = max(subsets, key=lambda s: len(s - covered)/costs[subsets.index(s)])
        cover.append(subset)
        cost+=costs[subsets.index(subset)]
        covered |= subset

    return cover, cost

def main(a,b,c,x=time.time()):
    m= a
    universe = set(range(1, m+1))
    sub = b

    subsets = [set(x) for x in sub]
    costs =  c
    cover = set_cover(universe, subsets,costs)
    print('covering sets= ',cover[0],'\n',
          'cost= ',cover[1],'$')
    print('time: ',time.time()-x)

m1= 5
S1 = [[1,3],[2],[1,2,5],[3,5],[4],[5],[1,3],[2,4,5],[1,2],[2,3]]
P1 = [11,4,9,12,5,4,13,12,8,9]
m2 = 15
S2 = [[2, 7, 8, 10, 12, 13], [1, 3, 5, 8, 10, 11, 12, 15], [1, 2, 3, 4, 5, 6, 7, 12, 13], [2, 6, 7, 11, 12, 13], [9, 10, 12, 13], [1, 3, 7, 9, 11, 12, 13], [1, 3, 5, 6, 8, 9, 10, 11, 12, 13], [1, 3, 4, 5, 6, 7, 12, 14, 15], [1, 2, 3, 6, 11, 12], [1, 2, 4, 5, 7, 8], [5, 9, 10, 11, 15], [3, 5, 6, 7, 8, 9, 12, 13, 14], [1, 3, 4, 5, 6, 7, 9, 11, 13, 14, 15], [1, 3, 5, 6, 8, 12, 14], [2, 4, 7, 9, 10, 12, 14], [1, 3, 5, 6, 11, 15], [2, 3, 4, 5, 6, 8, 10, 11, 12, 13, 14, 15], [1, 2, 4, 6, 7, 11, 13, 14, 15], [1, 2, 8, 12, 13, 14], [1, 2, 6, 7, 8, 13], [1, 2, 3, 5, 7, 8, 10, 12, 14, 15], [4, 5, 7, 12, 15], [1, 2, 3, 5, 11, 14], [1, 6, 8, 11, 13], [1, 6, 7, 8, 9, 10, 13], [1, 2, 3, 4, 5, 9, 11, 15], [2, 3, 4, 7, 9, 11, 12], [1, 3, 4, 5, 8, 10, 11, 12, 13], [2, 8, 9, 10], [6, 11, 13], [2, 5, 6, 8, 9, 11, 12, 13, 15], [2, 4, 6, 7, 8, 9, 10, 11, 13, 15], [1, 2, 3, 4, 5, 7, 8, 10, 11], [1, 2, 6, 9, 11, 13, 14, 15], [1, 4, 9, 10, 11, 13, 15], [1, 2, 3, 4, 6, 8, 12, 14, 15], [4, 5, 7, 8, 10, 13, 14], [2, 4, 8, 9, 11, 14], [2, 3, 4, 5, 6, 7, 10, 11, 14], [1, 2, 4, 5, 6, 7, 9, 11, 13, 14, 15], [1, 2, 6, 7, 9, 10, 12, 15], [1, 3, 6, 9, 10, 15], [2, 3, 5, 7, 8, 9, 11], [2, 3, 4, 5, 8, 10, 11, 12, 15], [1, 3, 4, 5, 6, 7, 9, 10, 12, 15]]
P2 = [16, 7, 16, 39, 29, 35, 19, 27, 27, 33, 38, 8, 41, 16, 12, 7, 41, 6, 34, 48, 23, 16, 31, 18, 35, 31, 41, 21, 50, 21, 12, 37, 35, 44, 48, 18, 14, 26, 22, 13, 29, 34, 28, 45, 50]
m3 = 5
S3 = [[1], [1, 2, 3, 4, 5], [2, 3], [2, 3, 4, 5], [1, 3, 4], [5], [1, 2, 4], [1, 3, 4, 5], [3, 5], [4, 5], [3], [2, 5], [4], [1, 5], [2], [1, 2, 4], [1, 3], [1, 3, 5], [2, 4, 5], [2], [1, 2, 5]]
P3 = [44, 44, 39, 24, 5, 30, 26, 42, 28, 12, 6, 45, 37, 33, 5, 42, 26, 6, 38, 11, 28]
m4 = 40
S4 = [[1, 3, 4, 6, 7, 9, 10, 15, 16, 18, 26, 31, 32, 35, 36, 38, 39, 40], [1, 2, 3, 4, 5, 7, 9, 11, 13, 15, 17, 18, 19, 20, 23, 24, 25, 27, 31, 32, 37, 39, 40], [4, 7, 8, 10, 11, 14, 16, 17, 18, 20, 23, 24, 27, 28, 29, 34, 36, 37, 39, 40], [2, 3, 4, 7, 9, 11, 17, 20, 22, 25, 26, 27, 28, 32, 34, 35, 36, 37, 39, 40], [1, 2, 4, 6, 7, 10, 12, 13, 22, 23, 24, 26, 28, 30, 32, 33, 35, 36, 39], [1, 3, 4, 5, 6, 8, 9, 10, 12, 13, 16, 24, 25, 30, 34, 35, 36, 37, 38, 39], [2, 3, 5, 10, 11, 12, 14, 18, 20, 22, 24, 25, 27, 28, 30, 31, 33, 34, 40], [1, 3, 11, 12, 18, 19, 21, 22, 24, 25, 26, 30, 33, 35], [1, 2, 7, 9, 10, 11, 14, 16, 18, 20, 22, 25, 28, 33, 35, 38], [3, 4, 9, 10, 14, 15, 17, 18, 19, 23, 24, 26, 28, 29, 30, 32, 34, 35, 38, 39, 40], [1, 2, 3, 4, 5, 6, 7, 9, 10, 13, 14, 15, 16, 19, 20, 22, 23, 29, 30, 31, 36, 38, 39], [2, 4, 5, 7, 13, 14, 15, 17, 20, 23, 24, 25, 27, 28, 29, 30, 34, 35], [1, 2, 4, 8, 9, 11, 14, 15, 16, 17, 18, 19, 20, 21, 23, 24, 26, 27, 31, 32, 33, 34, 35, 36, 37, 39, 40], [1, 4, 5, 6, 8, 10, 14, 17, 20, 21, 23, 24, 25, 29, 30, 40], [3, 5, 6, 10, 12, 14, 16, 17, 18, 19, 20, 22, 23, 24, 26, 28, 29, 30, 31, 32, 33, 34, 37, 39], [2, 3, 5, 6, 7, 9, 14, 15, 16, 17, 20, 21, 23, 27, 28, 29, 31, 32, 34, 35, 39, 40], [2, 5, 7, 10, 11, 13, 14, 18, 20, 22, 23, 29, 32, 33, 34, 35, 38, 39], [1, 3, 6, 7, 8, 9, 10, 12, 13, 24, 29, 30, 33, 34, 35, 36, 37, 39, 40], [1, 2, 5, 6, 8, 9, 10, 11, 12, 13, 14, 16, 20, 21, 26, 29, 30, 32, 33, 35, 36, 38, 39, 40], [3, 4, 7, 8, 11, 14, 16, 17, 19, 20, 21, 22, 23, 24, 25, 26, 29, 30, 31, 33, 34, 36, 38, 39], [2, 3, 4, 6, 7, 9, 11, 13, 14, 15, 16, 19, 21, 24, 25, 26, 27, 28, 29, 30, 31, 33, 36, 39], [1, 2, 3, 6, 8, 10, 11, 13, 15, 16, 17, 19, 20, 21, 22, 25, 26, 34, 35, 36, 39, 40], [1, 2, 7, 12, 15, 17, 21, 24, 25, 27, 28, 30, 35, 37, 39, 40]]
P4 = [59, 68, 56, 50, 75, 95, 71, 66, 30, 28, 42, 50, 68, 34, 29, 52, 70, 85, 27, 40, 76, 82, 38]
m5 = 30
n5 = 23
S5 = [[2, 3, 4, 8, 9, 10, 11, 12, 15, 16, 18, 19, 22, 23, 24, 26, 27, 28, 29], [1, 2, 4, 5, 7, 8, 10, 11, 13, 16, 17, 19, 20, 21, 22, 23, 25, 27, 30], [1, 3, 9, 10, 16, 17, 18, 23, 24, 25, 26, 29, 30], [2, 4, 5, 6, 7, 10, 11, 12, 13, 14, 17, 20, 21, 22, 26, 27, 29, 30], [1, 6, 7, 11, 14, 17, 18, 23, 25, 26, 28, 29], [3, 5, 6, 7, 9, 10, 12, 13, 15, 16, 17, 18, 19, 21, 22, 24, 25, 26, 29], [2, 5, 6, 7, 8, 9, 10, 13, 17, 19, 20, 21, 23, 24, 25, 27, 28, 29, 30], [1, 5, 6, 8, 10, 19, 21, 24], [1, 3, 7, 8, 9, 10, 15, 19, 25, 26, 27, 30], [4, 5, 10, 11, 12, 13, 14, 16, 18, 20, 21, 22, 27, 28, 29], [1, 6, 7, 9, 17, 23, 26, 29, 30], [3, 4, 7, 8, 12, 13, 14, 15, 19, 21, 22, 24, 25, 27, 28, 29, 30], [1, 5, 6, 7, 8, 10, 15, 19, 21, 22, 27, 28, 29, 30], [1, 2, 4, 5, 6, 7, 8, 9, 11, 13, 14, 17, 19, 20, 23, 25, 26, 28, 30], [2, 3, 4, 9, 12, 15, 17, 20, 23, 26, 27, 28, 29], [4, 7, 8, 9, 11, 12, 13, 14, 15, 16, 19, 20, 25, 26, 27, 28, 29, 30], [1, 3, 5, 7, 8, 9, 18, 19, 20, 21, 22, 23, 26, 28, 29], [1, 3, 6, 7, 8, 10, 12, 13, 14, 16, 21, 23, 24, 25, 26, 27], [3, 5, 8, 9, 12, 13, 15, 18, 20, 21, 23, 24, 29], [1, 3, 4, 5, 8, 9, 10, 14, 15, 16, 18, 19, 20, 21, 22, 24, 26, 27], [2, 5, 8, 9, 12, 13, 14, 15, 17, 19, 20, 21, 24, 27, 28, 30], [2, 4, 8, 9, 12, 15, 16, 23, 24, 27, 28], [4, 5, 9, 10, 11, 12, 14, 15, 19, 22, 23, 27, 30]]
P5 = [60, 79, 49, 65, 88, 83, 38, 44, 54, 100, 65, 53, 43, 73, 63, 35, 65, 92, 74, 79, 67, 34, 95]
if __name__ == '__main__':
    main(m1,S1,P1)
    main(m2,S2,P2)
    main(m3,S3,P3)
    main(m4,S4,P4)
    main(m5,S5,P5)

__author__ = "Andrea Rubbi"
import time

def bypassbranch(subset, i):#bypass a branch
    for j in range(i-1, -1, -1):
        if subset[j] == 0:
            subset[j] = 1
            return subset, j+1

    return subset, 0

def nextvertex(subset, i, m):
    if i < m:
        subset[i] = 0
        return subset, i+1
    else:
        for j in range(m-1, -1, -1):
            if subset[j] == 0:
                subset[j] = 1
                return subset, j+1

    return subset, 0

def BB(universe,sets,costs):
    subset = [1 for x in range(len(sets))]#all sets in
    subset[0] = 0
    bestCost = sum(costs) #actually the worst cost
    i = 1

    while i > 0:

        if i < len(sets):
            cost, tSet = 0, set()# t for temporary
            for k in range(i):
                cost += subset[k]*costs[k]#if 1 adds the cost to total
                if subset[k] == 1: tSet.update(set(sets[k]))#if 1 add the set to the cover

            if cost > bestCost:#if the cost is larger than the currently best one, no need of further investigation
                subset, i = bypassbranch(subset, i)
                continue
            for k in range(i, len(sets)): tSet.update(set(sets[k]))
            if tSet != universe:#that means that the set was essential at this point to complete the uni.
                subset, i = bypassbranch(subset, i)
            else:
                subset, i = nextvertex(subset, i, len(sets))

        else:
            cost, fSet = 0, set()# f for final
            for k in range(i):
            	cost += subset[k]*costs[k]
            	if subset[k] == 1: fSet.update(set(sets[k]))

            if cost < bestCost and fSet == universe:
            	bestCost = cost
            	bestSubset = subset[:]
            subset, i = nextvertex(subset, i , len(sets))

    return bestCost, bestSubset

def main(a,b,c,z=time.time()):
    m = a
    S = b
    C = c
    F = set([x for x in range(1,m+1)])
    X=(BB(F,S,C))
    cost= X[0]
    sets= X[1]
    cover= []
    for x in range(len(sets)):
        if sets[x]==1:
            cover.append(S[x])
    print('covering sets: ',cover,'\n','total cost: ',cost,'$')
    print('time:',time.time()-z)

m1= 5
S1 = [[1,3],[2],[1,2,5],[3,5],[4],[5],[1,3],[2,4,5],[1,2],[2,3]]
P1 = [11,4,9,12,5,4,13,12,8,9]
m2 = 15
S2 = [[2, 7, 8, 10, 12, 13], [1, 3, 5, 8, 10, 11, 12, 15], [1, 2, 3, 4, 5, 6, 7, 12, 13], [2, 6, 7, 11, 12, 13], [9, 10, 12, 13], [1, 3, 7, 9, 11, 12, 13], [1, 3, 5, 6, 8, 9, 10, 11, 12, 13], [1, 3, 4, 5, 6, 7, 12, 14, 15], [1, 2, 3, 6, 11, 12], [1, 2, 4, 5, 7, 8], [5, 9, 10, 11, 15], [3, 5, 6, 7, 8, 9, 12, 13, 14], [1, 3, 4, 5, 6, 7, 9, 11, 13, 14, 15], [1, 3, 5, 6, 8, 12, 14], [2, 4, 7, 9, 10, 12, 14], [1, 3, 5, 6, 11, 15], [2, 3, 4, 5, 6, 8, 10, 11, 12, 13, 14, 15], [1, 2, 4, 6, 7, 11, 13, 14, 15], [1, 2, 8, 12, 13, 14], [1, 2, 6, 7, 8, 13], [1, 2, 3, 5, 7, 8, 10, 12, 14, 15], [4, 5, 7, 12, 15], [1, 2, 3, 5, 11, 14], [1, 6, 8, 11, 13], [1, 6, 7, 8, 9, 10, 13], [1, 2, 3, 4, 5, 9, 11, 15], [2, 3, 4, 7, 9, 11, 12], [1, 3, 4, 5, 8, 10, 11, 12, 13], [2, 8, 9, 10], [6, 11, 13], [2, 5, 6, 8, 9, 11, 12, 13, 15], [2, 4, 6, 7, 8, 9, 10, 11, 13, 15], [1, 2, 3, 4, 5, 7, 8, 10, 11], [1, 2, 6, 9, 11, 13, 14, 15], [1, 4, 9, 10, 11, 13, 15], [1, 2, 3, 4, 6, 8, 12, 14, 15], [4, 5, 7, 8, 10, 13, 14], [2, 4, 8, 9, 11, 14], [2, 3, 4, 5, 6, 7, 10, 11, 14], [1, 2, 4, 5, 6, 7, 9, 11, 13, 14, 15], [1, 2, 6, 7, 9, 10, 12, 15], [1, 3, 6, 9, 10, 15], [2, 3, 5, 7, 8, 9, 11], [2, 3, 4, 5, 8, 10, 11, 12, 15], [1, 3, 4, 5, 6, 7, 9, 10, 12, 15]]
P2 = [16, 7, 16, 39, 29, 35, 19, 27, 27, 33, 38, 8, 41, 16, 12, 7, 41, 6, 34, 48, 23, 16, 31, 18, 35, 31, 41, 21, 50, 21, 12, 37, 35, 44, 48, 18, 14, 26, 22, 13, 29, 34, 28, 45, 50]
m3 = 5
S3 = [[1], [1, 2, 3, 4, 5], [2, 3], [2, 3, 4, 5], [1, 3, 4], [5], [1, 2, 4], [1, 3, 4, 5], [3, 5], [4, 5], [3], [2, 5], [4], [1, 5], [2], [1, 2, 4], [1, 3], [1, 3, 5], [2, 4, 5], [2], [1, 2, 5]]
P3 = [44, 44, 39, 24, 5, 30, 26, 42, 28, 12, 6, 45, 37, 33, 5, 42, 26, 6, 38, 11, 28]
m4 = 40
S4 = [[1, 3, 4, 6, 7, 9, 10, 15, 16, 18, 26, 31, 32, 35, 36, 38, 39, 40], [1, 2, 3, 4, 5, 7, 9, 11, 13, 15, 17, 18, 19, 20, 23, 24, 25, 27, 31, 32, 37, 39, 40], [4, 7, 8, 10, 11, 14, 16, 17, 18, 20, 23, 24, 27, 28, 29, 34, 36, 37, 39, 40], [2, 3, 4, 7, 9, 11, 17, 20, 22, 25, 26, 27, 28, 32, 34, 35, 36, 37, 39, 40], [1, 2, 4, 6, 7, 10, 12, 13, 22, 23, 24, 26, 28, 30, 32, 33, 35, 36, 39], [1, 3, 4, 5, 6, 8, 9, 10, 12, 13, 16, 24, 25, 30, 34, 35, 36, 37, 38, 39], [2, 3, 5, 10, 11, 12, 14, 18, 20, 22, 24, 25, 27, 28, 30, 31, 33, 34, 40], [1, 3, 11, 12, 18, 19, 21, 22, 24, 25, 26, 30, 33, 35], [1, 2, 7, 9, 10, 11, 14, 16, 18, 20, 22, 25, 28, 33, 35, 38], [3, 4, 9, 10, 14, 15, 17, 18, 19, 23, 24, 26, 28, 29, 30, 32, 34, 35, 38, 39, 40], [1, 2, 3, 4, 5, 6, 7, 9, 10, 13, 14, 15, 16, 19, 20, 22, 23, 29, 30, 31, 36, 38, 39], [2, 4, 5, 7, 13, 14, 15, 17, 20, 23, 24, 25, 27, 28, 29, 30, 34, 35], [1, 2, 4, 8, 9, 11, 14, 15, 16, 17, 18, 19, 20, 21, 23, 24, 26, 27, 31, 32, 33, 34, 35, 36, 37, 39, 40], [1, 4, 5, 6, 8, 10, 14, 17, 20, 21, 23, 24, 25, 29, 30, 40], [3, 5, 6, 10, 12, 14, 16, 17, 18, 19, 20, 22, 23, 24, 26, 28, 29, 30, 31, 32, 33, 34, 37, 39], [2, 3, 5, 6, 7, 9, 14, 15, 16, 17, 20, 21, 23, 27, 28, 29, 31, 32, 34, 35, 39, 40], [2, 5, 7, 10, 11, 13, 14, 18, 20, 22, 23, 29, 32, 33, 34, 35, 38, 39], [1, 3, 6, 7, 8, 9, 10, 12, 13, 24, 29, 30, 33, 34, 35, 36, 37, 39, 40], [1, 2, 5, 6, 8, 9, 10, 11, 12, 13, 14, 16, 20, 21, 26, 29, 30, 32, 33, 35, 36, 38, 39, 40], [3, 4, 7, 8, 11, 14, 16, 17, 19, 20, 21, 22, 23, 24, 25, 26, 29, 30, 31, 33, 34, 36, 38, 39], [2, 3, 4, 6, 7, 9, 11, 13, 14, 15, 16, 19, 21, 24, 25, 26, 27, 28, 29, 30, 31, 33, 36, 39], [1, 2, 3, 6, 8, 10, 11, 13, 15, 16, 17, 19, 20, 21, 22, 25, 26, 34, 35, 36, 39, 40], [1, 2, 7, 12, 15, 17, 21, 24, 25, 27, 28, 30, 35, 37, 39, 40]]
P4 = [59, 68, 56, 50, 75, 95, 71, 66, 30, 28, 42, 50, 68, 34, 29, 52, 70, 85, 27, 40, 76, 82, 38]
m5 = 30
n5 = 23
S5 = [[2, 3, 4, 8, 9, 10, 11, 12, 15, 16, 18, 19, 22, 23, 24, 26, 27, 28, 29], [1, 2, 4, 5, 7, 8, 10, 11, 13, 16, 17, 19, 20, 21, 22, 23, 25, 27, 30], [1, 3, 9, 10, 16, 17, 18, 23, 24, 25, 26, 29, 30], [2, 4, 5, 6, 7, 10, 11, 12, 13, 14, 17, 20, 21, 22, 26, 27, 29, 30], [1, 6, 7, 11, 14, 17, 18, 23, 25, 26, 28, 29], [3, 5, 6, 7, 9, 10, 12, 13, 15, 16, 17, 18, 19, 21, 22, 24, 25, 26, 29], [2, 5, 6, 7, 8, 9, 10, 13, 17, 19, 20, 21, 23, 24, 25, 27, 28, 29, 30], [1, 5, 6, 8, 10, 19, 21, 24], [1, 3, 7, 8, 9, 10, 15, 19, 25, 26, 27, 30], [4, 5, 10, 11, 12, 13, 14, 16, 18, 20, 21, 22, 27, 28, 29], [1, 6, 7, 9, 17, 23, 26, 29, 30], [3, 4, 7, 8, 12, 13, 14, 15, 19, 21, 22, 24, 25, 27, 28, 29, 30], [1, 5, 6, 7, 8, 10, 15, 19, 21, 22, 27, 28, 29, 30], [1, 2, 4, 5, 6, 7, 8, 9, 11, 13, 14, 17, 19, 20, 23, 25, 26, 28, 30], [2, 3, 4, 9, 12, 15, 17, 20, 23, 26, 27, 28, 29], [4, 7, 8, 9, 11, 12, 13, 14, 15, 16, 19, 20, 25, 26, 27, 28, 29, 30], [1, 3, 5, 7, 8, 9, 18, 19, 20, 21, 22, 23, 26, 28, 29], [1, 3, 6, 7, 8, 10, 12, 13, 14, 16, 21, 23, 24, 25, 26, 27], [3, 5, 8, 9, 12, 13, 15, 18, 20, 21, 23, 24, 29], [1, 3, 4, 5, 8, 9, 10, 14, 15, 16, 18, 19, 20, 21, 22, 24, 26, 27], [2, 5, 8, 9, 12, 13, 14, 15, 17, 19, 20, 21, 24, 27, 28, 30], [2, 4, 8, 9, 12, 15, 16, 23, 24, 27, 28], [4, 5, 9, 10, 11, 12, 14, 15, 19, 22, 23, 27, 30]]
P5 = [60, 79, 49, 65, 88, 83, 38, 44, 54, 100, 65, 53, 43, 73, 63, 35, 65, 92, 74, 79, 67, 34, 95]
if __name__=='__main__':
    main(m1,S1,P1)
    main(m2,S2,P2)
    main(m3,S3,P3)
    main(m4,S4,P4)
    main(m5,S5,P5)

import time
import random
import csv
import matplotlib.pyplot as plt

# ==============================================================================
# ALGORITHM 1: GREEDY APPROXIMATION (Your Code)
# ==============================================================================
def set_cover(universe, subsets, costs):
    """
    Finds an approximate solution to the set cover problem using a greedy algorithm.
    """
    cost = 0
    # The universe is already provided as a set, so no need to recalculate.
    elements = universe
    covered = set()
    cover = []

    # Create a list of tuples (subset, cost) to avoid repeated index lookups
    subsets_with_costs = list(zip(subsets, costs))

    while covered != elements:
        # Find the best subset based on cost-effectiveness
        best_subset_info = max(
            subsets_with_costs,
            key=lambda sc: len(set(sc[0]) - covered) / sc[1] if sc[1] > 0 else float('inf')
        )

        subset_to_add = best_subset_info[0]
        cost_of_subset = best_subset_info[1]

        # Add the chosen subset to our cover
        cover.append(subset_to_add)
        cost += cost_of_subset
        covered.update(subset_to_add)

        # Remove the chosen subset to prevent it from being selected again
        # This is important for correctness if subsets can be identical
        subsets_with_costs.remove(best_subset_info)

    return cover, cost

# ==============================================================================
# ALGORITHM 2: EXACT SOLVER - BRANCH & BOUND (Your Code)
# ==============================================================================
def bypassbranch(subset, i):
    """Helper for BB: Bypasses a branch in the search tree."""
    for j in range(i - 1, -1, -1):
        if subset[j] == 0:
            subset[j] = 1
            return subset, j + 1
    return subset, 0

def nextvertex(subset, i, m):
    """Helper for BB: Moves to the next vertex in the search tree."""
    if i < m:
        subset[i] = 0
        return subset, i + 1
    else:
        for j in range(m - 1, -1, -1):
            if subset[j] == 0:
                subset[j] = 1
                return subset, j + 1
    return subset, 0

def BB(universe, sets, costs):
    """
    Finds the exact, optimal solution using a Branch and Bound algorithm.
    """
    num_sets = len(sets)
    subset_selection = [1] * num_sets
    subset_selection[0] = 0

    best_cost = sum(costs)
    best_subset_selection = [1] * num_sets

    i = 1
    while i > 0:
        if i < num_sets:
            current_cost, temp_set_coverage = 0, set()
            for k in range(i):
                if subset_selection[k] == 1:
                    current_cost += costs[k]
                    temp_set_coverage.update(sets[k])

            if current_cost >= best_cost:
                subset_selection, i = bypassbranch(subset_selection, i)
                continue

            potential_coverage = temp_set_coverage.copy()
            for k in range(i, num_sets):
                potential_coverage.update(sets[k])

            if potential_coverage != universe:
                subset_selection, i = bypassbranch(subset_selection, i)
            else:
                subset_selection, i = nextvertex(subset_selection, i, num_sets)
        else:
            final_cost, final_set_coverage = 0, set()
            for k in range(len(subset_selection)):
                if subset_selection[k] == 1:
                    final_cost += costs[k]
                    final_set_coverage.update(sets[k])

            if final_cost < best_cost and final_set_coverage == universe:
                best_cost = final_cost
                best_subset_selection = subset_selection[:]

            subset_selection, i = nextvertex(subset_selection, i, num_sets)

    # Reconstruct the final covering sets from the best selection
    final_cover = []
    for idx, selected in enumerate(best_subset_selection):
        if selected == 1:
            final_cover.append(sets[idx])

    return final_cover, best_cost

# ==============================================================================
# STEP 1: INSTANCE GENERATION
# ==============================================================================
def generate_random_instance(num_elements, num_subsets):
    """
    Generates a random Set Cover problem instance.
    Ensures that the generated instance is solvable.
    """
    universe = set(range(1, num_elements + 1))
    subsets = []

    # Ensure every element is in at least one subset to guarantee a solution exists
    elements_to_cover = list(universe)
    random.shuffle(elements_to_cover)

    current_subset = set()
    for element in elements_to_cover:
        current_subset.add(element)
        if random.random() > 0.5: # Randomly decide to "finish" a subset
            subsets.append(list(current_subset))
            current_subset = set()
    if current_subset:
        subsets.append(list(current_subset))

    # Generate additional random subsets to reach the desired number
    while len(subsets) < num_subsets:
        size = random.randint(1, num_elements // 2)
        subset = random.sample(list(universe), size)
        subsets.append(subset)

    costs = [random.randint(1, 100) for _ in range(len(subsets))]

    return universe, subsets, costs

# ==============================================================================
# STEP 2: EXPERIMENT RUNNER
# ==============================================================================
def run_experiment(min_sets, max_sets, num_elements):
    """
    Runs both algorithms on a range of problem sizes and logs results to a CSV file.
    """
    results_filename = "set_cover_experiment_results.csv"

    with open(results_filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        # Write the header row
        writer.writerow([
            "num_sets", "num_elements",
            "greedy_cost", "greedy_time",
            "exact_cost", "exact_time"
        ])

        print("Starting experiment... Results will be saved to", results_filename)
        # Loop through problem sizes (number of subsets)
        for i in range(min_sets, max_sets + 1):
            print(f"\nRunning for problem size: {i} subsets, {num_elements} elements")

            # Generate a consistent problem for both algorithms
            universe, subsets, costs = generate_random_instance(num_elements, i)

            # --- Run Greedy Algorithm ---
            start_time = time.time()
            _, greedy_cost = set_cover(universe, subsets, costs)
            greedy_time = time.time() - start_time
            print(f"  Greedy -> Cost: {greedy_cost}, Time: {greedy_time:.4f}s")

            # --- Run Exact Algorithm ---
            start_time = time.time()
            _, exact_cost = BB(universe, subsets, costs) # Corrected 'sets' to 'subsets'
            exact_time = time.time() - start_time
            print(f"  Exact  -> Cost: {exact_cost}, Time: {exact_time:.4f}s")

            # Write the results for this problem size to the CSV
            writer.writerow([
                i, num_elements,
                greedy_cost, greedy_time,
                exact_cost, exact_time
            ])

    print("\nExperiment finished!")
    return results_filename

# ==============================================================================
# STEP 3: ANALYSIS AND PLOTTING
# ==============================================================================
def analyze_and_plot(results_filename):
    """
    Reads the CSV results and creates the two required plots.
    """
    # Read the data from the CSV file
    num_sets, greedy_costs, greedy_times, exact_costs, exact_times = [], [], [], [], []
    with open(results_filename, 'r') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            num_sets.append(int(row['num_sets']))
            greedy_costs.append(float(row['greedy_cost']))
            greedy_times.append(float(row['greedy_time']))
            exact_costs.append(float(row['exact_cost']))
            exact_times.append(float(row['exact_time']))

    # --- Plot 1: Solution Quality Comparison ---
    plt.figure(figsize=(10, 6))
    plt.plot(num_sets, greedy_costs, 'o-', label='Greedy Algorithm Cost', color='orange')
    plt.plot(num_sets, exact_costs, 's-', label='Optimal (Exact) Cost', color='blue')
    plt.title('Solution Quality: Greedy vs. Exact Algorithm')
    plt.xlabel('Number of Subsets (Problem Size)')
    plt.ylabel('Total Cost of Set Cover')
    plt.legend()
    plt.grid(True)
    plt.savefig('solution_quality_comparison.png')
    print("Saved plot: solution_quality_comparison.png")

    # --- Plot 2: Runtime Explosion (Log Scale) ---
    plt.figure(figsize=(10, 6))
    plt.plot(num_sets, greedy_times, 'o-', label='Greedy Algorithm Runtime', color='orange')
    plt.plot(num_sets, exact_times, 's-', label='Exact Algorithm Runtime', color='blue')
    plt.yscale('log') # Use a logarithmic scale for the y-axis!
    plt.title('Runtime Comparison: Greedy vs. Exact Algorithm')
    plt.xlabel('Number of Subsets (Problem Size)')
    plt.ylabel('Runtime in Seconds (Log Scale)')
    plt.legend()
    plt.grid(True)
    plt.savefig('runtime_explosion.png')
    print("Saved plot: runtime_explosion.png")

    plt.show()


# ==============================================================================
# MAIN EXECUTION
# ==============================================================================
if __name__ == '__main__':
    # --- Configuration ---
    # WARNING: The exact solver's runtime grows exponentially.
    # Start with a small range, e.g., MIN_SETS=5, MAX_SETS=15.
    # Increasing MAX_SETS beyond ~20 can lead to extremely long run times.
    MIN_SETS = 5
    MAX_SETS = 15
    NUM_ELEMENTS = 50 # The size of the universe to cover

    # --- Run the full pipeline ---
    results_file = run_experiment(MIN_SETS, MAX_SETS, NUM_ELEMENTS)
    analyze_and_plot(results_file)

import time
import random
import csv
import matplotlib.pyplot as plt
from scipy.optimize import linprog

# ==============================================================================
# ALGORITHM 1: GREEDY APPROXIMATION
# ==============================================================================
def set_cover(universe, subsets, costs):
    """
    Finds an approximate solution to the set cover problem using a greedy algorithm.
    """
    cost = 0
    elements = universe
    covered = set()
    cover = []
    subsets_with_costs = list(zip(subsets, costs))

    while covered != elements:
        if not subsets_with_costs: # Should not happen if a solution exists
            break
        best_subset_info = max(
            subsets_with_costs,
            key=lambda sc: len(set(sc[0]) - covered) / sc[1] if sc[1] > 0 else float('inf')
        )
        subset_to_add, cost_of_subset = best_subset_info

        if len(set(subset_to_add) - covered) == 0:
            # Avoids infinite loops if remaining sets cover no new elements
            break

        cover.append(subset_to_add)
        cost += cost_of_subset
        covered.update(subset_to_add)
        subsets_with_costs.remove(best_subset_info)

    return cover, cost

# ==============================================================================
# ALGORITHM 2: EXACT SOLVER - BRANCH & BOUND
# ==============================================================================
def bypassbranch(subset, i):
    for j in range(i - 1, -1, -1):
        if subset[j] == 0:
            subset[j] = 1
            return subset, j + 1
    return subset, 0

def nextvertex(subset, i, m):
    if i < m:
        subset[i] = 0
        return subset, i + 1
    else:
        for j in range(m - 1, -1, -1):
            if subset[j] == 0:
                subset[j] = 1
                return subset, j + 1
    return subset, 0

def BB(universe, sets, costs):
    """
    Finds the exact, optimal solution using a Branch and Bound algorithm.
    """
    num_sets = len(sets)
    subset_selection = [1] * num_sets
    if not subset_selection: return [], 0
    subset_selection[0] = 0

    best_cost = sum(costs)
    best_subset_selection = [1] * num_sets

    i = 1
    while i > 0:
        if i < num_sets:
            current_cost, temp_set_coverage = 0, set()
            for k in range(i):
                if subset_selection[k] == 1:
                    current_cost += costs[k]
                    temp_set_coverage.update(sets[k])

            if current_cost >= best_cost:
                subset_selection, i = bypassbranch(subset_selection, i)
                continue

            potential_coverage = temp_set_coverage.copy()
            for k in range(i, num_sets):
                potential_coverage.update(sets[k])

            if potential_coverage != universe:
                subset_selection, i = bypassbranch(subset_selection, i)
            else:
                subset_selection, i = nextvertex(subset_selection, i, num_sets)
        else:
            final_cost, final_set_coverage = 0, set()
            for k in range(len(subset_selection)):
                if subset_selection[k] == 1:
                    final_cost += costs[k]
                    final_set_coverage.update(sets[k])

            if final_cost < best_cost and final_set_coverage == universe:
                best_cost = final_cost
                best_subset_selection = subset_selection[:]

            subset_selection, i = nextvertex(subset_selection, i, num_sets)

    final_cover = [sets[idx] for idx, sel in enumerate(best_subset_selection) if sel == 1]
    return final_cover, best_cost

# ==============================================================================
# ALGORITHM 3: LP RELAXATION + ROUNDING
# ==============================================================================
def lp_set_cover(universe, subsets, costs):
    """
    Finds an approximate solution to set cover using LP Relaxation and rounding.
    """
    num_subsets = len(subsets)
    num_elements = len(universe)
    c = costs
    element_map = {element: i for i, element in enumerate(universe)}
    A_ub = [[0] * num_subsets for _ in range(num_elements)]

    for j, subset in enumerate(subsets):
        for element in subset:
            if element in element_map:
                i = element_map[element]
                A_ub[i][j] = -1

    b_ub = [-1] * num_elements
    x_bounds = (0, 1)

    result = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=x_bounds, method='highs')

    if not result.success:
        print("Warning: LP solver failed. Falling back to greedy algorithm.")
        return set_cover(universe, subsets, costs)

    cover, total_cost = [], 0
    for j, is_chosen in enumerate(result.x):
        if is_chosen > 1e-5:
            cover.append(subsets[j])
            total_cost += costs[j]

    # Verify the rounded solution is a valid cover
    final_coverage = set(e for s in cover for e in s)
    if final_coverage != universe:
       # Simple repair step: greedily add sets to cover remaining elements
       uncovered = universe - final_coverage
       while uncovered:
           temp_universe = uncovered.copy()
           # Find the best set to cover the *remaining* elements
           best_set, best_cost = None, 0
           max_covered = 0
           for s, c in zip(subsets, costs):
               newly_covered = len(uncovered.intersection(s))
               if newly_covered > max_covered:
                   max_covered = newly_covered
                   best_set, best_cost = s, c
           if best_set:
               cover.append(best_set)
               total_cost += best_cost
               uncovered -= set(best_set)
           else: # No single set can cover more, break to avoid infinite loop
               break

    return cover, total_cost

# ==============================================================================
# STEP 1: SYNTHETIC DATA GENERATION
# ==============================================================================
def generate_diagnostic_panel_problem(num_diseases, num_markers):
    """
    Generates a synthetic dataset for the genetic diagnostic panel problem.
    """
    print(f"\nGenerating a problem with {num_diseases} diseases and {num_markers} markers...")
    universe = set(range(1, num_diseases + 1))
    subsets, costs = [], []

    for _ in range(num_markers):
        if random.random() < 0.8: # Common-disease marker
            upper_bound = max(2, int(num_diseases * 0.1)) # Ensure upper bound is at least 2
            num_diseases_covered = random.randint(2, upper_bound)
            cost = random.randint(20, 100)
        else: # Rare-disease marker
            num_diseases_covered = random.randint(1, 2)
            cost = random.randint(150, 500)
        marker_coverage = random.sample(list(universe), num_diseases_covered)
        subsets.append(marker_coverage)
        costs.append(cost)

    covered_diseases = set(e for s in subsets for e in s)
    missing_diseases = universe - covered_diseases
    if missing_diseases:
        print(f"Found {len(missing_diseases)} uncovered diseases. Creating dedicated markers...")
        for disease in missing_diseases:
            subsets.append([disease])
            costs.append(random.randint(400, 600))

    return universe, subsets, costs

# ==============================================================================
# STEP 2: EXPERIMENT RUNNER
# ==============================================================================
def run_experiment(problem_configs):
    """
    Runs all three algorithms on a list of problem configurations.
    """
    results_filename = "diagnostic_panel_results.csv"
    with open(results_filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow([
            "num_diseases", "num_markers",
            "greedy_cost", "greedy_time",
            "lp_cost", "lp_time",
            "exact_cost", "exact_time"
        ])

        print("Starting experiment... Results will be saved to", results_filename)
        for diseases, markers in problem_configs:
            universe, subsets, costs = generate_diagnostic_panel_problem(diseases, markers)

            # --- Run Greedy Algorithm ---
            start_time = time.time()
            _, greedy_cost = set_cover(universe, subsets, costs)
            greedy_time = time.time() - start_time
            print(f"  Greedy -> Cost: ${greedy_cost:,.2f}, Time: {greedy_time:.4f}s")

            # --- Run LP Relaxation Algorithm ---
            start_time = time.time()
            _, lp_cost = lp_set_cover(universe, subsets, costs)
            lp_time = time.time() - start_time
            print(f"  LP     -> Cost: ${lp_cost:,.2f}, Time: {lp_time:.4f}s")

            # --- Run Exact Algorithm (only for small problems) ---
            exact_cost, exact_time = "N/A", "N/A"
            if diseases <= 20 and markers <= 40:
                start_time = time.time()
                _, exact_cost = BB(universe, subsets, costs)
                exact_time = time.time() - start_time
                print(f"  Exact  -> Cost: ${exact_cost:,.2f}, Time: {exact_time:.4f}s")
            else:
                 print(f"  Exact  -> Skipped (problem too large)")


            writer.writerow([diseases, markers, greedy_cost, greedy_time, lp_cost, lp_time, exact_cost, exact_time])

    print("\nExperiment finished!")
    return results_filename

# ==============================================================================
# STEP 3: ANALYSIS AND PLOTTING
# ==============================================================================
def analyze_and_plot(results_filename):
    """
    Reads the CSV results and creates comparative plots.
    """
    data = {"num_markers": [], "greedy_cost": [], "lp_cost": [], "exact_cost": [],
            "greedy_time": [], "lp_time": [], "exact_time": []}

    with open(results_filename, 'r') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            data["num_markers"].append(int(row['num_markers']))
            data["greedy_cost"].append(float(row['greedy_cost']))
            data["lp_cost"].append(float(row['lp_cost']))
            data["greedy_time"].append(float(row['greedy_time']))
            data["lp_time"].append(float(row['lp_time']))
            if row['exact_cost'] != 'N/A':
                data["exact_cost"].append(float(row['exact_cost']))
                data["exact_time"].append(float(row['exact_time']))
            else: # Append placeholder to keep lists aligned
                data["exact_cost"].append(None)
                data["exact_time"].append(None)


    # Filter out the N/A values for the exact plot
    exact_plot_markers = [m for m, c in zip(data["num_markers"], data["exact_cost"]) if c is not None]
    exact_plot_costs = [c for c in data["exact_cost"] if c is not None]
    exact_plot_times = [t for t in data["exact_time"] if t is not None]

    # --- Plot 1: Solution Quality (Cost) ---
    plt.figure(figsize=(12, 7))
    plt.plot(data["num_markers"], data["greedy_cost"], 'o-', label='Greedy Panel Cost', color='orange')
    plt.plot(data["num_markers"], data["lp_cost"], '^-', label='LP Panel Cost', color='green')
    if exact_plot_markers:
        plt.plot(exact_plot_markers, exact_plot_costs, 's-', label='Optimal Panel Cost (Exact)', color='blue')
    plt.title('Cost of Genetic Diagnostic Panels')
    plt.xlabel('Number of Available Genetic Markers')
    plt.ylabel('Total Cost of Panel ($)')
    plt.legend()
    plt.grid(True)
    plt.savefig('panel_cost_comparison.png')
    print("Saved plot: panel_cost_comparison.png")

    # --- Plot 2: Runtime Comparison ---
    plt.figure(figsize=(12, 7))
    plt.plot(data["num_markers"], data["greedy_time"], 'o-', label='Greedy Runtime', color='orange')
    plt.plot(data["num_markers"], data["lp_time"], '^-', label='LP Runtime', color='green')
    if exact_plot_markers:
        plt.plot(exact_plot_markers, exact_plot_times, 's-', label='Exact Runtime', color='blue')
    plt.yscale('log')
    plt.title('Algorithm Runtime Comparison (Log Scale)')
    plt.xlabel('Number of Available Genetic Markers')
    plt.ylabel('Runtime in Seconds (Log Scale)')
    plt.legend()
    plt.grid(True)
    plt.savefig('panel_runtime_comparison.png')
    print("Saved plot: panel_runtime_comparison.png")

    plt.show()

# ==============================================================================
# MAIN EXECUTION
# ==============================================================================
if __name__ == '__main__':
    # --- Configuration ---
    # Define the sizes of the problems you want to test.
    # Start with a few small ones to include the exact solver, then scale up.
    PROBLEM_CONFIGURATIONS = [
        # (num_diseases, num_markers)
        (15, 30),
        (20, 40),
        (50, 100),
        (100, 250),
        (200, 500),
        (500, 1000)
    ]

    # --- Run the full pipeline ---
    results_file = run_experiment(PROBLEM_CONFIGURATIONS)
    analyze_and_plot(results_file)